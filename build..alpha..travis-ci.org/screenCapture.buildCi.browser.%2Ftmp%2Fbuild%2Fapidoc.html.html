<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/ternjs/tern#readme">tern (v0.21.0)</a>
</h1>
<h4>A JavaScript code analyzer for deep, cross-editor language support</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern">module tern</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server">
            function <span class="apidocSignatureSpan">tern.</span>Server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.addCompletion">
            function <span class="apidocSignatureSpan">tern.</span>addCompletion
            <span class="apidocSignatureSpan">(query, completions, name, aval, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.defineQueryType">
            function <span class="apidocSignatureSpan">tern.</span>defineQueryType
            <span class="apidocSignatureSpan">(name, desc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.findQueryExpr">
            function <span class="apidocSignatureSpan">tern.</span>findQueryExpr
            <span class="apidocSignatureSpan">(file, query, wide)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.getSpan">
            function <span class="apidocSignatureSpan">tern.</span>getSpan
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.outputPos">
            function <span class="apidocSignatureSpan">tern.</span>outputPos
            <span class="apidocSignatureSpan">(query, file, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.registerPlugin">
            function <span class="apidocSignatureSpan">tern.</span>registerPlugin
            <span class="apidocSignatureSpan">(name, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.resolvePos">
            function <span class="apidocSignatureSpan">tern.</span>resolvePos
            <span class="apidocSignatureSpan">(file, pos, tolerant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.storeSpan">
            function <span class="apidocSignatureSpan">tern.</span>storeSpan
            <span class="apidocSignatureSpan">(srv, query, span, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>comment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>condense</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>def</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>infer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.</span>signal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tern.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.Server">module tern.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.Server">
            function <span class="apidocSignatureSpan">tern.</span>Server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.Server.prototype">module tern.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.addDefs">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>addDefs
            <span class="apidocSignatureSpan">(defs, toFront)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.addFile">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>addFile
            <span class="apidocSignatureSpan">(name, text, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.delFile">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>delFile
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.deleteDefs">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>deleteDefs
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.findFile">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>findFile
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.finishAsyncAction">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>finishAsyncAction
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.flush">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>flush
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.hasHandler">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>hasHandler
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.loadPlugin">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>loadPlugin
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.normalizeFilename">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>normalizeFilename
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.off">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>off
            <span class="apidocSignatureSpan">(type, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.on">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>on
            <span class="apidocSignatureSpan">(type, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.request">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>request
            <span class="apidocSignatureSpan">(doc, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.reset">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.signal">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>signal
            <span class="apidocSignatureSpan">(type, a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.signalReturnFirst">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>signalReturnFirst
            <span class="apidocSignatureSpan">(type, a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.Server.prototype.startAsyncAction">
            function <span class="apidocSignatureSpan">tern.Server.prototype.</span>startAsyncAction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.comment">module tern.comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.comment.commentAfter">
            function <span class="apidocSignatureSpan">tern.comment.</span>commentAfter
            <span class="apidocSignatureSpan">(text, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.comment.commentsBefore">
            function <span class="apidocSignatureSpan">tern.comment.</span>commentsBefore
            <span class="apidocSignatureSpan">(text, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.comment.ensureCommentsBefore">
            function <span class="apidocSignatureSpan">tern.comment.</span>ensureCommentsBefore
            <span class="apidocSignatureSpan">(text, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.condense">module tern.condense</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.condense.condense">
            function <span class="apidocSignatureSpan">tern.</span>condense
            <span class="apidocSignatureSpan">(origins, name, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.def">module tern.def</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.def.init">
            function <span class="apidocSignatureSpan">tern.def.</span>init
            <span class="apidocSignatureSpan">(exports, infer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.defaultOptions">module tern.defaultOptions</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tern.defaultOptions.</span>async</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tern.defaultOptions.</span>debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tern.defaultOptions.</span>reuseInstances</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tern.defaultOptions.</span>stripCRs</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.defaultOptions.getFile">
            function <span class="apidocSignatureSpan">tern.defaultOptions.</span>getFile
            <span class="apidocSignatureSpan">(_f, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.defaultOptions.normalizeFilename">
            function <span class="apidocSignatureSpan">tern.defaultOptions.</span>normalizeFilename
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">tern.defaultOptions.</span>dependencyBudget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">tern.defaultOptions.</span>ecmaVersion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">tern.defaultOptions.</span>fetchTimeout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.defaultOptions.</span>defs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.defaultOptions.</span>parent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.defaultOptions.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tern.defaultOptions.</span>projectDir</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.infer">module tern.infer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.AVal">
            function <span class="apidocSignatureSpan">tern.infer.</span>AVal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Arr">
            function <span class="apidocSignatureSpan">tern.infer.</span>Arr
            <span class="apidocSignatureSpan">(contentType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Context">
            function <span class="apidocSignatureSpan">tern.infer.</span>Context
            <span class="apidocSignatureSpan">(defs, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.DefProp">
            function <span class="apidocSignatureSpan">tern.infer.</span>DefProp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Fn">
            function <span class="apidocSignatureSpan">tern.infer.</span>Fn
            <span class="apidocSignatureSpan">(name, self, args, argNames, retval, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.IfObj">
            function <span class="apidocSignatureSpan">tern.infer.</span>IfObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.IsCallee">
            function <span class="apidocSignatureSpan">tern.infer.</span>IsCallee
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.IsCtor">
            function <span class="apidocSignatureSpan">tern.infer.</span>IsCtor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.IsProto">
            function <span class="apidocSignatureSpan">tern.infer.</span>IsProto
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Obj">
            function <span class="apidocSignatureSpan">tern.infer.</span>Obj
            <span class="apidocSignatureSpan">(proto, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Prim">
            function <span class="apidocSignatureSpan">tern.infer.</span>Prim
            <span class="apidocSignatureSpan">(proto, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.PropHasSubset">
            function <span class="apidocSignatureSpan">tern.infer.</span>PropHasSubset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Scope">
            function <span class="apidocSignatureSpan">tern.infer.</span>Scope
            <span class="apidocSignatureSpan">(prev, originNode, isBlock, isCatch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Sym">
            function <span class="apidocSignatureSpan">tern.infer.</span>Sym
            <span class="apidocSignatureSpan">(name, originNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.TimedOut">
            function <span class="apidocSignatureSpan">tern.infer.</span>TimedOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.Type">
            function <span class="apidocSignatureSpan">tern.infer.</span>Type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.addOrigin">
            function <span class="apidocSignatureSpan">tern.infer.</span>addOrigin
            <span class="apidocSignatureSpan">(origin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.analyze">
            function <span class="apidocSignatureSpan">tern.infer.</span>analyze
            <span class="apidocSignatureSpan">(ast, name, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.clearScopes">
            function <span class="apidocSignatureSpan">tern.infer.</span>clearScopes
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.constraint">
            function <span class="apidocSignatureSpan">tern.infer.</span>constraint
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.cx">
            function <span class="apidocSignatureSpan">tern.infer.</span>cx
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.didGuess">
            function <span class="apidocSignatureSpan">tern.infer.</span>didGuess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.expressionType">
            function <span class="apidocSignatureSpan">tern.infer.</span>expressionType
            <span class="apidocSignatureSpan">(found)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.findExpressionAround">
            function <span class="apidocSignatureSpan">tern.infer.</span>findExpressionAround
            <span class="apidocSignatureSpan">(ast, start, end, defaultScope, filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.findExpressionAt">
            function <span class="apidocSignatureSpan">tern.infer.</span>findExpressionAt
            <span class="apidocSignatureSpan">(ast, start, end, defaultScope, filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.findPropRefs">
            function <span class="apidocSignatureSpan">tern.infer.</span>findPropRefs
            <span class="apidocSignatureSpan">(ast, scope, objType, name, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.findRefs">
            function <span class="apidocSignatureSpan">tern.infer.</span>findRefs
            <span class="apidocSignatureSpan">(ast, baseScope, name, refScope, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.forAllLocalsAt">
            function <span class="apidocSignatureSpan">tern.infer.</span>forAllLocalsAt
            <span class="apidocSignatureSpan">(ast, pos, defaultScope, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.forAllPropertiesOf">
            function <span class="apidocSignatureSpan">tern.infer.</span>forAllPropertiesOf
            <span class="apidocSignatureSpan">(type, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.getInstance">
            function <span class="apidocSignatureSpan">tern.infer.</span>getInstance
            <span class="apidocSignatureSpan">(obj, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.getSymbol">
            function <span class="apidocSignatureSpan">tern.infer.</span>getSymbol
            <span class="apidocSignatureSpan">(name, originNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.parentNode">
            function <span class="apidocSignatureSpan">tern.infer.</span>parentNode
            <span class="apidocSignatureSpan">(child, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.parse">
            function <span class="apidocSignatureSpan">tern.infer.</span>parse
            <span class="apidocSignatureSpan">(text, options, thirdArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.propName">
            function <span class="apidocSignatureSpan">tern.infer.</span>propName
            <span class="apidocSignatureSpan">(node, inferInScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.purge">
            function <span class="apidocSignatureSpan">tern.infer.</span>purge
            <span class="apidocSignatureSpan">(origins, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.registerFunction">
            function <span class="apidocSignatureSpan">tern.infer.</span>registerFunction
            <span class="apidocSignatureSpan">(name, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.resetGuessing">
            function <span class="apidocSignatureSpan">tern.infer.</span>resetGuessing
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.scopeAt">
            function <span class="apidocSignatureSpan">tern.infer.</span>scopeAt
            <span class="apidocSignatureSpan">(ast, pos, defaultScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.simplifyTypes">
            function <span class="apidocSignatureSpan">tern.infer.</span>simplifyTypes
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.toString">
            function <span class="apidocSignatureSpan">tern.infer.</span>toString
            <span class="apidocSignatureSpan">(type, maxDepth, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.typeFromContext">
            function <span class="apidocSignatureSpan">tern.infer.</span>typeFromContext
            <span class="apidocSignatureSpan">(ast, found)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.withContext">
            function <span class="apidocSignatureSpan">tern.infer.</span>withContext
            <span class="apidocSignatureSpan">(context, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.infer.withTimeout">
            function <span class="apidocSignatureSpan">tern.infer.</span>withTimeout
            <span class="apidocSignatureSpan">(ms, f)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>ANull</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>def</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>findTypeFromContext</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>fullVisitor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>inferExprVisitor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>inferPatternVisitor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>inferWrapper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>scopeGatherer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>searchVisitor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tern.infer.</span>typeFinder</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tern.signal">module tern.signal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tern.signal.mixin">
            function <span class="apidocSignatureSpan">tern.signal.</span>mixin
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern" id="apidoc.module.tern">module tern</a></h1>


    <h2>
        <a href="#apidoc.element.tern.Server" id="apidoc.element.tern.Server">
        function <span class="apidocSignatureSpan">tern.</span>Server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (options) {
  this.cx = null;
  this.options = options || {};
  for (var o in defaultOptions) if (!options.hasOwnProperty(o))
    options[o] = defaultOptions[o];

  this.projectDir = options.projectDir.replace(/\\/g, "/")
  if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

  this.parent = options.parent;
  this.handlers = Object.create(null);
  this.files = [];
  this.fileMap = Object.create(null);
  this.needsPurge = [];
  this.budgets = Object.create(null);
  this.uses = 0;
  this.pending = 0;
  this.asyncError = null;
  this.mod = {}

  this.defs = options.defs.slice(0)
  this.plugins = Object.create(null)
  for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
    this.loadPlugin(plugin, options.plugins[plugin])

  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (cur.charAt(0) == "-") {
    usage(1);
  } else {
    files.push(cur);
  }
}

var server = new tern.<span class="apidocCodeKeywordSpan">Server</span>({
  getFile: function(file) { return fs.readFileSync(path.resolve(localDir, file), "utf8"); },
  defs: defs,
  plugins: plugins,
  debug: true,
  projectDir: localDir
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.addCompletion" id="apidoc.element.tern.addCompletion">
        function <span class="apidocSignatureSpan">tern.</span>addCompletion
        <span class="apidocSignatureSpan">(query, completions, name, aval, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCompletion = function (query, completions, name, aval, depth) {
  var typeInfo = query.types || query.docs || query.urls || query.origins;
  var wrapAsObjs = typeInfo || query.depths;

  for (var i = 0; i &lt; completions.length; ++i) {
    var c = completions[i];
    if ((wrapAsObjs ? c.name : c) == name) return;
  }
  var rec = wrapAsObjs ? {name: name} : name;
  completions.push(rec);

  if (aval &amp;&amp; typeInfo) {
    infer.resetGuessing();
    var type = aval.getType();
    rec.guess = infer.didGuess();
    if (query.types)
      rec.type = infer.toString(aval);
    if (query.docs)
      maybeSet(rec, "doc", parseDoc(query, aval.doc || type &amp;&amp; type.doc));
    if (query.urls)
      maybeSet(rec, "url", aval.url || type &amp;&amp; type.url);
    if (query.origins)
      maybeSet(rec, "origin", aval.origin || type &amp;&amp; type.origin);
  }
  if (query.depths) rec.depth = depth || 0;
  return rec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.modules[name] || (this.modules[name] = new infer.AVal)
    },

    completeModuleName: function(completions, query, word) {
function fromObj(obj, useVal) {
  for (var name in obj)
    if (filter(word, name, query))
      tern.<span class="apidocCodeKeywordSpan">addCompletion</span>(query, completions, name, useVal &amp;&amp; obj[name])
}

fromObj(this.knownModules, true)
if (this.options.modules) fromObj(this.options.modules, false)

var pathsSeen = Object.create(null)
for (var prop in this.nonRelative) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.defineQueryType" id="apidoc.element.tern.defineQueryType">
        function <span class="apidocSignatureSpan">tern.</span>defineQueryType
        <span class="apidocSignatureSpan">(name, desc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineQueryType = function (name, desc) { queryTypes[name] = desc; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
register &lt;a href="#tern.Server.on"&gt;event handlers&lt;/a&gt; on the server, &lt;a href="#tern.Server
.addDefs"&gt;add&lt;/a&gt;
type definitions, &lt;a href="#tern.Server.loadPlugin"&gt;load&lt;/a&gt; other plugins as dependencies,
and/or initialize the plugin&amp;#8217;s state.
&lt;/p&gt;
&lt;p&gt; See the server&amp;#8217;s &lt;a href="#events"&gt;list of events&lt;/a&gt; for ways to wire up
 plugin behavior.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="tern.defineQueryType"&gt;&lt;/a&gt;&lt;code&gt;tern.<span class="apidocCodeKeywordSpan">defineQueryType
</span>(name: string, desc: object)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Defines a new type of query with the server. The &lt;code&gt;desc&lt;/code&gt; object is a
property describing the request. It should at least have a &lt;code&gt;run&lt;/code&gt;
property, which holds a function &lt;code&gt;fn(Server, query)&lt;/code&gt; that will be
called to handle queries with a &lt;code&gt;type&lt;/code&gt; property that matches the given
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.findQueryExpr" id="apidoc.element.tern.findQueryExpr">
        function <span class="apidocSignatureSpan">tern.</span>findQueryExpr
        <span class="apidocSignatureSpan">(file, query, wide)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findQueryExpr = function (file, query, wide) {
  if (query.end == null) throw ternError("missing .query.end field");

  if (query.variable) {
    var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
    return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
            state: scope};
  } else {
    var start = query.start &amp;&amp; resolvePos(file, query.start), end = resolvePos(file, query.end);
    var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
    if (!expr) {
      var around = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (around &amp;&amp; !inBody(around.node, end) &amp;&amp;
          (around.node.type == "ObjectExpression" || wide ||
           (start == null ? end : start) - around.node.start &lt; 20 || around.node.end - end &lt; 20))
        expr = around
    }
    return expr
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.getSpan" id="apidoc.element.tern.getSpan">
        function <span class="apidocSignatureSpan">tern.</span>getSpan
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSpan = function (obj) {
  if (!obj.origin) return;
  if (obj.originNode) {
    var node = obj.originNode;
    if (/^Function/.test(node.type) &amp;&amp; node.id) node = node.id;
    return {origin: obj.origin, node: node};
  }
  if (obj.span) return {origin: obj.origin, span: obj.span};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!(actual instanceof infer.Prim)) actual.path = newPath;
  if (actual.reached(newPath, state, !relevant) &amp;&amp; relevant) {
    var data = state.types[oldPath];
    if (data) {
      delete state.types[oldPath];
      state.altPaths[oldPath] = actual;
    } else data = {type: actual};
    data.span = state.<span class="apidocCodeKeywordSpan">getSpan</span>(type) || (actual != type &amp;&amp; state.isTarget(actual
.origin) &amp;&amp; state.getSpan(actual)) || data.span;
    data.doc = type.doc || (actual != type &amp;&amp; state.isTarget(actual.origin) &amp;&amp; actual.doc) || data.doc;
    data.data = actual.metaData;
    data.byName = data.byName == null ? !!byName : data.byName &amp;&amp; byName;
    state.types[newPath] = data;
  }
} else {
  if (relevant) state.altPaths[newPath] = actual;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.outputPos" id="apidoc.element.tern.outputPos">
        function <span class="apidocSignatureSpan">tern.</span>outputPos
        <span class="apidocSignatureSpan">(query, file, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputPos = function (query, file, pos) {
  if (query.lineCharPositions) {
    var out = asLineChar(file, pos);
    if (file.type == "part")
      out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
    return out;
  } else {
    return charDistanceBetween(file, 0, pos) + (file.type == "part" ? file.offset : 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (query.types) rec.type = "string";
        if (query.origins) rec.origin = seen[str];
      } else {
        matches.push(JSON.stringify(str));
      }
    }
    if (matches.length) return {
      start: tern.<span class="apidocCodeKeywordSpan">outputPos</span>(query, file, lit.node.start),
      end: tern.outputPos(query, file, pos + (file.text.charAt(pos) == file.text.charAt(lit.node.start) ? 1 : 0)),
      isProperty: false,
      completions: matches
    };
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.registerPlugin" id="apidoc.element.tern.registerPlugin">
        function <span class="apidocSignatureSpan">tern.</span>registerPlugin
        <span class="apidocSignatureSpan">(name, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPlugin = function (name, init) { plugins[name] = init; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registered under &lt;code&gt;"myname"&lt;/code&gt; to be called with the argument types and
argument AST nodes given to the call. This is used, for example, to
make calls to &lt;code&gt;require&lt;/code&gt; trigger the necessary machinations to fetch a
dependency and return its type.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="tern.registerPlugin"&gt;&lt;/a&gt;&lt;code&gt;tern.<span class="apidocCodeKeywordSpan">registerPlugin
</span>(name: string, fn(Server, options))&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
This can be used to register an initialization function
for the plugin with the given name. A Tern server, when
&lt;a href="#option_plugins"&gt;configured&lt;/a&gt; to load this plugin, will call this
initialization function, passing in the server instance and the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.resolvePos" id="apidoc.element.tern.resolvePos">
        function <span class="apidocSignatureSpan">tern.</span>resolvePos
        <span class="apidocSignatureSpan">(file, pos, tolerant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolvePos = function (file, pos, tolerant) {
  if (typeof pos != "number") {
    var lineStart = findLineStart(file, pos.line);
    if (lineStart == null) {
      if (tolerant) pos = file.text.length;
      else throw ternError("File doesn't contain a line " + pos.line);
    } else {
      pos = forwardCharacters(file, lineStart, pos.ch);
    }
  } else {
    pos = forwardCharacters(file, 0, pos)
  }
  if (pos &gt; file.text.length) {
    if (tolerant) pos = file.text.length;
    else throw ternError("Position " + pos + " is outside of file.");
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (typeof node.value == "string" &amp;&amp; node.value &amp;&amp; node.value.length &lt; data.maxLen)
        data.seen[node.value] = ast.sourceFile.name;
    }
  });
}

function complete(file, query) {
  var pos = tern.<span class="apidocCodeKeywordSpan">resolvePos</span>(file, query.end);
  var lit = infer.findExpressionAround(file.ast, null, pos, file.scope, "Literal");
  if (!lit || typeof lit.node.value != "string") return;
  var before = lit.node.value.slice(0, pos - lit.node.start - 1);
  var matches = [], seen = infer.cx().parent.mod.completeStrings.seen;
  for (var str in seen) if (str.length &gt; before.length &amp;&amp; str.indexOf(before) == 0) {
    if (query.types || query.docs || query.urls || query.origins) {
      var rec = {name: JSON.stringify(str), displayName: str};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.storeSpan" id="apidoc.element.tern.storeSpan">
        function <span class="apidocSignatureSpan">tern.</span>storeSpan
        <span class="apidocSignatureSpan">(srv, query, span, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storeSpan = function (srv, query, span, target) {
  target.origin = span.origin;
  if (span.span) {
    var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
    target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
    target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
  } else {
    var file = srv.fileMap[span.origin];
    target.start = outputPos(query, file, span.node.start);
    target.end = outputPos(query, file, span.node.end);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function describe(aval) {
  var target = {}, type = aval.getType(false)
  target.type = infer.toString(type, 3)
  var doc = aval.doc || (type &amp;&amp; type.doc), url = aval.url || (type &amp;&amp; type.url)
  if (doc) target.doc = doc
  if (url) target.url = url
  var span = tern.getSpan(aval) || (type &amp;&amp; tern.getSpan(type))
  if (span) tern.<span class="apidocCodeKeywordSpan">storeSpan</span>(server, query, span, target)
  return target
}

var mod = server.mod.modules, known = mod &amp;&amp; mod.modules[file.name]
if (!known) return {}
var resp = describe(known);
var type = known.getType(false)
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.Server" id="apidoc.module.tern.Server">module tern.Server</a></h1>


    <h2>
        <a href="#apidoc.element.tern.Server.Server" id="apidoc.element.tern.Server.Server">
        function <span class="apidocSignatureSpan">tern.</span>Server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (options) {
  this.cx = null;
  this.options = options || {};
  for (var o in defaultOptions) if (!options.hasOwnProperty(o))
    options[o] = defaultOptions[o];

  this.projectDir = options.projectDir.replace(/\\/g, "/")
  if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

  this.parent = options.parent;
  this.handlers = Object.create(null);
  this.files = [];
  this.fileMap = Object.create(null);
  this.needsPurge = [];
  this.budgets = Object.create(null);
  this.uses = 0;
  this.pending = 0;
  this.asyncError = null;
  this.mod = {}

  this.defs = options.defs.slice(0)
  this.plugins = Object.create(null)
  for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
    this.loadPlugin(plugin, options.plugins[plugin])

  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (cur.charAt(0) == "-") {
    usage(1);
  } else {
    files.push(cur);
  }
}

var server = new tern.<span class="apidocCodeKeywordSpan">Server</span>({
  getFile: function(file) { return fs.readFileSync(path.resolve(localDir, file), "utf8"); },
  defs: defs,
  plugins: plugins,
  debug: true,
  projectDir: localDir
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.Server.prototype" id="apidoc.module.tern.Server.prototype">module tern.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.tern.Server.prototype.addDefs" id="apidoc.element.tern.Server.prototype.addDefs">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>addDefs
        <span class="apidocSignatureSpan">(defs, toFront)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDefs = function (defs, toFront) {
  if (toFront) this.defs.unshift(defs)
  else this.defs.push(defs)

  if (this.cx) this.reset()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (arguments.length == 1) options = this.options.plugins[name] || true
  if (name in this.plugins || !(name in plugins) || !options) return
  this.plugins[name] = true
  var init = plugins[name](this, options)

  // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly
  if (!init) return
  if (init.defs) this.<span class="apidocCodeKeywordSpan">addDefs</span>(init.defs, init.loadFirst)
  if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
    this.on(type, init.passes[type])
},

normalizeFilename: function(name) {
  var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
  if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.addFile" id="apidoc.element.tern.Server.prototype.addFile">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>addFile
        <span class="apidocSignatureSpan">(name, text, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFile = function (name, text, parent) {
  // Don't crash when sloppy plugins pass non-existent parent ids
  if (parent &amp;&amp; !(parent in this.fileMap)) parent = null;
  if (!(name in this.fileMap))
    name = this.normalizeFilename(name)
  ensureFile(this, name, parent, text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  origins.push(file);
  if (!name) name = file;
}
if (!fs.existsSync(file)) {
  console.error("File " + file + " does not exist");
  process.exit(1);
}
server.<span class="apidocCodeKeywordSpan">addFile</span>(file, fs.readFileSync(file, "utf8"));
}

if (!origins.length) usage(1);

server.flush(function(err) {
if (err) throw err;
console.log(JSON.stringify(condense.condense(origins, name, {spans: spans}), null, 2));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.delFile" id="apidoc.element.tern.Server.prototype.delFile">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>delFile
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delFile = function (name) {
  var file = this.findFile(name);
  if (file) {
    this.needsPurge.push(file.name);
    for (var i = 0; i &lt; this.files.length; i++) {
      if (this.files[i] == file) this.files.splice(i--, 1);
      else if (this.files[i].parent == name) this.files[i].parent = null;
    }
    delete this.fileMap[file.name];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var files = doc.files || [];
if (files.length) ++srv.uses;
for (var i = 0; i &lt; files.length; ++i) {
  var file = files[i];
  file.name = srv.normalizeFilename(file.name)
  if (file.type == "delete")
    srv.<span class="apidocCodeKeywordSpan">delFile</span>(file.name);
  else
    ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
}

var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
if (!query) {
  analyzeAll(srv, timeBudget, function(){});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.deleteDefs" id="apidoc.element.tern.Server.prototype.deleteDefs">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>deleteDefs
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteDefs = function (name) {
  for (var i = 0; i &lt; this.defs.length; i++) if (this.defs[i]["!name"] == name) {
    this.defs.splice(i, 1);
    if (this.cx) this.reset();
    return;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.findFile" id="apidoc.element.tern.Server.prototype.findFile">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>findFile
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findFile = function (name) {
  return this.fileMap[this.normalizeFilename(name)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.origins.indexOf(origin) &gt; -1;
};

State.prototype.getSpan = function(node) {
  if (this.options.spans == false || !this.isTarget(node.origin)) return null;
  if (node.span) return node.span;
  var srv = this.cx.parent, file;
  if (!srv || !node.originNode || !(file = srv.<span class="apidocCodeKeywordSpan">findFile</span>(node.origin))) return null;
  var start = node.originNode.start, end = node.originNode.end;
  var pStart = file.asLineChar(start), pEnd = file.asLineChar(end);
  return start + "[" + pStart.line + ":" + pStart.ch + "]-" +
    end + "[" + pEnd.line + ":" + pEnd.ch + "]";
};

function pathLen(path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.finishAsyncAction" id="apidoc.element.tern.Server.prototype.finishAsyncAction">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>finishAsyncAction
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishAsyncAction = function (err) {
  if (err) this.asyncError = err;
  if (--this.pending === 0) this.signal("everythingFetched");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  srv.fileMap[name] = file;
  if (text != null) {
    updateText(file, text, srv);
  } else if (srv.options.async) {
    srv.startAsyncAction();
    srv.options.getFile(name, function(err, text) {
      updateText(file, text || "", srv);
      srv.<span class="apidocCodeKeywordSpan">finishAsyncAction</span>(err);
    });
  } else {
    updateText(file, srv.options.getFile(name) || "", srv);
  }
}

function fetchAll(srv, c) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.flush" id="apidoc.element.tern.Server.prototype.flush">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>flush
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (c) {
  var cx = this.cx;
  analyzeAll(this, null, function(err) {
    if (err) return c(err);
    infer.withContext(cx, c);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    process.exit(1);
  }
  server.addFile(file, fs.readFileSync(file, "utf8"));
}

if (!origins.length) usage(1);

server.<span class="apidocCodeKeywordSpan">flush</span>(function(err) {
  if (err) throw err;
  console.log(JSON.stringify(condense.condense(origins, name, {spans: spans}), null, 2));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.hasHandler" id="apidoc.element.tern.Server.prototype.hasHandler">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>hasHandler
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasHandler(type) {
  var arr = this._handlers &amp;&amp; this._handlers[type]
  return arr &amp;&amp; arr.length &gt; 0 &amp;&amp; arr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  function findExprType(srv, query, file, expr) {
var type;
if (expr) {
  infer.resetGuessing();
  type = infer.expressionType(expr);
}
var typeHandlers = srv.<span class="apidocCodeKeywordSpan">hasHandler</span>("typeAt")
if (typeHandlers) {
  var pos = resolvePos(file, query.end)
  for (var i = 0; i &lt; typeHandlers.length; i++)
    type = typeHandlers[i](file, pos, expr, type)
}
if (!type) throw ternError("No type found at the given position.");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.loadPlugin" id="apidoc.element.tern.Server.prototype.loadPlugin">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>loadPlugin
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPlugin = function (name, options) {
  if (arguments.length == 1) options = this.options.plugins[name] || true
  if (name in this.plugins || !(name in plugins) || !options) return
  this.plugins[name] = true
  var init = plugins[name](this, options)

  // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly
  if (!init) return
  if (init.defs) this.addDefs(init.defs, init.loadFirst)
  if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
    this.on(type, init.passes[type])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.pending = 0;
  this.asyncError = null;
  this.mod = {}

  this.defs = options.defs.slice(0)
  this.plugins = Object.create(null)
  for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
    this.<span class="apidocCodeKeywordSpan">loadPlugin</span>(plugin, options.plugins[plugin])

  this.reset();
};
Server.prototype = signal.mixin({
  addFile: function(name, /*optional*/ text, parent) {
    // Don't crash when sloppy plugins pass non-existent parent ids
    if (parent &amp;&amp; !(parent in this.fileMap)) parent = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.normalizeFilename" id="apidoc.element.tern.Server.prototype.normalizeFilename">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>normalizeFilename
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeFilename = function (name) {
  var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
  if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
  return norm
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.reset();
};
Server.prototype = signal.mixin({
  addFile: function(name, /*optional*/ text, parent) {
    // Don't crash when sloppy plugins pass non-existent parent ids
    if (parent &amp;&amp; !(parent in this.fileMap)) parent = null;
    if (!(name in this.fileMap))
      name = this.<span class="apidocCodeKeywordSpan">normalizeFilename</span>(name)
    ensureFile(this, name, parent, text);
  },
  delFile: function(name) {
    var file = this.findFile(name);
    if (file) {
      this.needsPurge.push(file.name);
      for (var i = 0; i &lt; this.files.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.off" id="apidoc.element.tern.Server.prototype.off">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>off
        <span class="apidocSignatureSpan">(type, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function off(type, f) {
  var arr = this._handlers &amp;&amp; this._handlers[type];
  if (arr) for (var i = 0; i &lt; arr.length; ++i)
    if (arr[i] == f) { arr.splice(i, 1); break; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  });
  if (done) c();
}

function waitOnFetch(srv, timeBudget, c) {
  var done = function() {
    srv.<span class="apidocCodeKeywordSpan">off</span>("everythingFetched", done);
    clearTimeout(timeout);
    analyzeAll(srv, timeBudget, c);
  };
  srv.on("everythingFetched", done);
  var timeout = setTimeout(done, srv.options.fetchTimeout);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.on" id="apidoc.element.tern.Server.prototype.on">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>on
        <span class="apidocSignatureSpan">(type, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(type, f) {
  var handlers = this._handlers || (this._handlers = Object.create(null));
  (handlers[type] || (handlers[type] = [])).push(f);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var target = url.parse(req.url, true);
  if (target.pathname == "/ping") return respondSimple(resp, 200, "pong");
  if (target.pathname != "/") return respondSimple(resp, 404, "No service at " + target.pathname);

  if (req.method == "POST") {
    var body = "";
    req.<span class="apidocCodeKeywordSpan">on</span>("data", function (data) { body += data; });
    req.on("end", function() { respond(resp, body); });
  } else if (req.method == "GET") {
    if (target.query.doc) respond(resp, target.query.doc);
    else respondSimple(resp, 400, "Missing query document");
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.request" id="apidoc.element.tern.Server.prototype.request">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>request
        <span class="apidocSignatureSpan">(doc, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (doc, c) {
  var inv = invalidDoc(doc);
  if (inv) return c(inv);

  var self = this;
  doRequest(this, doc, function(err, data) {
    c(err, data);
    if (self.uses &gt; 40) {
      self.reset();
      analyzeAll(self, null, function(){});
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function respond(resp, doc) {
  try { var doc = JSON.parse(doc); }
  catch(e) { return respondSimple(resp, 400, "JSON parse error: " + e.message); }
  if (verbose) console.log("Request: " + JSON.stringify(doc, null, 2));

  server.<span class="apidocCodeKeywordSpan">request</span>(doc, function(err, data) {
    if (err) return respondSimple(resp, 400, String(err));
    resp.writeHead(200, {"content-type": "application/json; charset=utf-8"});
    if (verbose) console.log("Response: " + JSON.stringify(data, null, 2) + "\n");
    resp.end(JSON.stringify(data));
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.reset" id="apidoc.element.tern.Server.prototype.reset">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  this.signal("reset");
  this.cx = new infer.Context(this.defs, this);
  this.uses = 0;
  this.budgets = Object.create(null);
  for (var i = 0; i &lt; this.files.length; ++i) {
    var file = this.files[i];
    if (file.scope) {
      infer.clearScopes(file.ast);
      file.scope = null;
    }
  }
  this.signal("postReset");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.mod = {}

  this.defs = options.defs.slice(0)
  this.plugins = Object.create(null)
  for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
    this.loadPlugin(plugin, options.plugins[plugin])

  this.<span class="apidocCodeKeywordSpan">reset</span>();
};
Server.prototype = signal.mixin({
  addFile: function(name, /*optional*/ text, parent) {
    // Don't crash when sloppy plugins pass non-existent parent ids
    if (parent &amp;&amp; !(parent in this.fileMap)) parent = null;
    if (!(name in this.fileMap))
      name = this.normalizeFilename(name)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.signal" id="apidoc.element.tern.Server.prototype.signal">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>signal
        <span class="apidocSignatureSpan">(type, a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signal(type, a1, a2, a3, a4) {
  var arr = getHandlers(this, type)
  for (var i = 0; i &lt; arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})(this, function(exports, infer) {
  "use strict";

  exports.condense = function(origins, name, options) {
if (typeof origins == "string") origins = [origins];
var state = new State(origins, name || origins[0], options || {});

state.server.<span class="apidocCodeKeywordSpan">signal</span>("preCondenseReach", state)

state.cx.topScope.path = "&lt;top&gt;";
state.cx.topScope.reached("", state);
for (var path in state.roots)
  reach(state.roots[path], null, path, state);
for (var i = 0; i &lt; state.patchUp.length; ++i)
  patchUpSimpleInstance(state.patchUp[i], state);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.signalReturnFirst" id="apidoc.element.tern.Server.prototype.signalReturnFirst">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>signalReturnFirst
        <span class="apidocSignatureSpan">(type, a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signalReturnFirst(type, a1, a2, a3, a4) {
  var arr = getHandlers(this, type)
  for (var i = 0; i &lt; arr.length; ++i) {
    var result = arr[i].call(this, a1, a2, a3, a4)
    if (result) return result
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var options = {
    directSourceFile: file,
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true,
    ecmaVersion: srv.options.ecmaVersion,
    allowHashBang: true
  }
  var text = srv.<span class="apidocCodeKeywordSpan">signalReturnFirst</span>("preParse", file.text, options) || file.
text
  var ast = infer.parse(text, options)
  srv.signal("postParse", ast, text)
  return ast
}

var astral = /[\uD800-\uDBFF]/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.Server.prototype.startAsyncAction" id="apidoc.element.tern.Server.prototype.startAsyncAction">
        function <span class="apidocSignatureSpan">tern.Server.prototype.</span>startAsyncAction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startAsyncAction = function () {
  ++this.pending;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var file = new File(name, parent);
srv.files.push(file);
srv.fileMap[name] = file;
if (text != null) {
  updateText(file, text, srv);
} else if (srv.options.async) {
  srv.<span class="apidocCodeKeywordSpan">startAsyncAction</span>();
  srv.options.getFile(name, function(err, text) {
    updateText(file, text || "", srv);
    srv.finishAsyncAction(err);
  });
} else {
  updateText(file, srv.options.getFile(name) || "", srv);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.comment" id="apidoc.module.tern.comment">module tern.comment</a></h1>


    <h2>
        <a href="#apidoc.element.tern.comment.commentAfter" id="apidoc.element.tern.comment.commentAfter">
        function <span class="apidocSignatureSpan">tern.comment.</span>commentAfter
        <span class="apidocSignatureSpan">(text, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentAfter = function (text, pos) {
  while (pos &lt; text.length) {
    var next = text.charCodeAt(pos);
    if (next == 47) {
      var after = text.charCodeAt(pos + 1), end;
      if (after == 47) // line comment
        end = text.indexOf("\n", pos + 2);
      else if (after == 42) // block comment
        end = text.indexOf("*/", pos + 2);
      else
        return;
      return text.slice(pos + 2, end &lt; 0 ? text.length : end);
    } else if (isSpace(next)) {
      ++pos;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.comment.commentsBefore" id="apidoc.element.tern.comment.commentsBefore">
        function <span class="apidocSignatureSpan">tern.comment.</span>commentsBefore
        <span class="apidocSignatureSpan">(text, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentsBefore = function (text, pos) {
  var found = null, emptyLines = 0, topIsLineComment;
  out: while (pos &gt; 0) {
    var prev = text.charCodeAt(pos - 1);
    if (prev == 10) {
      for (var scan = --pos, sawNonWS = false; scan &gt; 0; --scan) {
        prev = text.charCodeAt(scan - 1);
        if (prev == 47 &amp;&amp; text.charCodeAt(scan - 2) == 47) {
          if (!onOwnLine(text, scan - 2)) break out;
          var content = text.slice(scan, pos);
          if (!emptyLines &amp;&amp; topIsLineComment) found[0] = content + "\n" + found[0];
          else (found || (found = [])).unshift(content);
          topIsLineComment = true;
          emptyLines = 0;
          pos = scan - 2;
          break;
        } else if (prev == 10) {
          if (!sawNonWS &amp;&amp; ++emptyLines &gt; 1) break out;
          break;
        } else if (!sawNonWS &amp;&amp; !isSpace(prev)) {
          sawNonWS = true;
        }
      }
    } else if (prev == 47 &amp;&amp; text.charCodeAt(pos - 2) == 42) {
      for (var scan = pos - 2; scan &gt; 1; --scan) {
        if (text.charCodeAt(scan - 1) == 42 &amp;&amp; text.charCodeAt(scan - 2) == 47) {
          if (!onOwnLine(text, scan - 2)) break out;
          (found || (found = [])).unshift(text.slice(scan, pos - 2));
          topIsLineComment = false;
          emptyLines = 0;
          break;
        }
      }
      pos = scan - 2;
    } else if (isSpace(prev)) {
      --pos;
    } else {
      break;
    }
  }
  return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function(text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.<span class="apidocCodeKeywordSpan">commentsBefore</span>(text, node.start);
  };
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.comment.ensureCommentsBefore" id="apidoc.element.tern.comment.ensureCommentsBefore">
        function <span class="apidocSignatureSpan">tern.comment.</span>ensureCommentsBefore
        <span class="apidocSignatureSpan">(text, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureCommentsBefore = function (text, node) {
  if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
  return node.commentsBefore = exports.commentsBefore(text, node.start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.on("postParse", postParse)
server.on("postInfer", postInfer)
server.on("postLoadDef", postLoadDef)
  });

  function postParse(ast, text) {
function attachComments(node) { comment.<span class="apidocCodeKeywordSpan">ensureCommentsBefore</span>(text, node); }

walk.simple(ast, {
  VariableDeclaration: attachComments,
  FunctionDeclaration: attachComments,
  MethodDefinition: attachComments,
  Property: attachComments,
  AssignmentExpression: function(node) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.condense" id="apidoc.module.tern.condense">module tern.condense</a></h1>


    <h2>
        <a href="#apidoc.element.tern.condense.condense" id="apidoc.element.tern.condense.condense">
        function <span class="apidocSignatureSpan">tern.</span>condense
        <span class="apidocSignatureSpan">(origins, name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">condense = function (origins, name, options) {
  if (typeof origins == "string") origins = [origins];
  var state = new State(origins, name || origins[0], options || {});

  state.server.signal("preCondenseReach", state)

  state.cx.topScope.path = "&lt;top&gt;";
  state.cx.topScope.reached("", state);
  for (var path in state.roots)
    reach(state.roots[path], null, path, state);
  for (var i = 0; i &lt; state.patchUp.length; ++i)
    patchUpSimpleInstance(state.patchUp[i], state);

  state.server.signal("postCondenseReach", state)

  for (var path in state.types)
    store(createPath(path.split("."), state), state.types[path], state);
  for (var path in state.altPaths)
    storeAlt(path, state.altPaths[path], state);
  var hasDef = false;
  for (var _def in state.output["!define"]) { hasDef = true; break; }
  if (!hasDef) delete state.output["!define"];

  state.server.signal("postCondense", state)

  return simplify(state.output, state.options.sortOutput);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  server.addFile(file, fs.readFileSync(file, "utf8"));
}

if (!origins.length) usage(1);

server.flush(function(err) {
  if (err) throw err;
  console.log(JSON.stringify(condense.<span class="apidocCodeKeywordSpan">condense</span>(origins, name, {spans: spans}), null,
2));
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.def" id="apidoc.module.tern.def">module tern.def</a></h1>


    <h2>
        <a href="#apidoc.element.tern.def.init" id="apidoc.element.tern.def.init">
        function <span class="apidocSignatureSpan">tern.def.</span>init
        <span class="apidocSignatureSpan">(exports, infer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(name, args, retType, generator) {
    return function(self, cArgs) {
      var realArgs = [];
      for (var i = 0; i &lt; args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
    };
  }
  function computedUnion(types) {
    return function(self, args) {
      var union = new infer.AVal;
      for (var i = 0; i &lt; types.length; i++) unwrapType(types[i], self, args).propagate(union);
      union.maxWeight = 1e5;
      return union;
    };
  }
  function computedArray(inner) {
    return function(self, args) {
      return new infer.Arr(inner(self, args));
    };
  }
  function computedTuple(types) {
    return function(self, args) {
      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
    }
  }
  function computedObject(names, types) {
    return function(self, args) {
      var obj = new infer.Obj;
      names.forEach(function (prop, i) {
        obj.defProp(prop).addType(unwrapType(types[i], self, args));
      });
      return obj;
    };
  }

  TypeParser.prototype = {
    eat: function(str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function(re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) &amp;&amp; re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function() {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function(comp, name, top, generator) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^(\.\.\.)?[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -&gt; ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call &amp;&amp; !computed) {
          computeRet = retType;
          retType = infer.ANull;
          computeRetStart = retStart;
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(name, args, retType, generator);

      if (top &amp;&amp; (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function(comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (;;) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };

  // INIT DEF MODULE

  // Delayed initialization because of cyclic dependencies.
  def = exports.def = def.<span class="apidocCodeKeywordSpan">init</span>({}, exports);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.defaultOptions" id="apidoc.module.tern.defaultOptions">module tern.defaultOptions</a></h1>










    <h2>
        <a href="#apidoc.element.tern.defaultOptions.getFile" id="apidoc.element.tern.defaultOptions.getFile">
        function <span class="apidocSignatureSpan">tern.defaultOptions.</span>getFile
        <span class="apidocSignatureSpan">(_f, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFile = function (_f, c) { if (this.async) c(null, null); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var file = new File(name, parent);
  srv.files.push(file);
  srv.fileMap[name] = file;
  if (text != null) {
    updateText(file, text, srv);
  } else if (srv.options.async) {
    srv.startAsyncAction();
    srv.options.<span class="apidocCodeKeywordSpan">getFile</span>(name, function(err, text) {
      updateText(file, text || "", srv);
      srv.finishAsyncAction(err);
    });
  } else {
    updateText(file, srv.options.getFile(name) || "", srv);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.defaultOptions.normalizeFilename" id="apidoc.element.tern.defaultOptions.normalizeFilename">
        function <span class="apidocSignatureSpan">tern.defaultOptions.</span>normalizeFilename
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeFilename = function (name) { return name }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.reset();
};
Server.prototype = signal.mixin({
  addFile: function(name, /*optional*/ text, parent) {
    // Don't crash when sloppy plugins pass non-existent parent ids
    if (parent &amp;&amp; !(parent in this.fileMap)) parent = null;
    if (!(name in this.fileMap))
      name = this.<span class="apidocCodeKeywordSpan">normalizeFilename</span>(name)
    ensureFile(this, name, parent, text);
  },
  delFile: function(name) {
    var file = this.findFile(name);
    if (file) {
      this.needsPurge.push(file.name);
      for (var i = 0; i &lt; this.files.length; i++) {
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.infer" id="apidoc.module.tern.infer">module tern.infer</a></h1>


    <h2>
        <a href="#apidoc.element.tern.infer.AVal" id="apidoc.element.tern.infer.AVal">
        function <span class="apidocSignatureSpan">tern.infer.</span>AVal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AVal = function () {
  this.types = [];
  this.forward = null;
  this.maxWeight = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
example, a variable can hold two different types of values, the
associated abstract value will hold both these types. In some cases,
no type can be assigned to something at all, in which case the
abstract value remains empty.&lt;/p&gt;
&lt;p&gt; Abstract values expose the following interface:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.AVal"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">AVal</span>()&lt;
;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Constructor. Creates an empty AVal.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Arr" id="apidoc.element.tern.infer.Arr">
        function <span class="apidocSignatureSpan">tern.infer.</span>Arr
        <span class="apidocSignatureSpan">(contentType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Arr = function (contentType) {
  Obj.call(this, cx.protos.Array)
  var content = this.defProp("&lt;i&gt;")
  if (Array.isArray(contentType)) {
    this.tuple = contentType.length
    for (var i = 0; i &lt; contentType.length; i++) {
      var prop = this.defProp(String(i))
      contentType[i].propagate(prop)
      prop.propagate(content)
    }
  } else if (contentType) {
    this.tuple = 0
    contentType.propagate(content)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Constructor for the type that implements functions. Inherits from
&lt;a href="#infer.Obj"&gt;Obj&lt;/a&gt;. The &lt;a href="#infer_aval"&gt;&lt;code&gt;AVal&amp;#
x3c;/code&gt;&lt;/a&gt; types are used to track
the input and output types of the function.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.Arr"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">Arr</span>(contentType
: AVal)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Constructor that creates
an array type with the given content type.
&lt;/p&gt;
&lt;/dd&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Context" id="apidoc.element.tern.infer.Context">
        function <span class="apidocSignatureSpan">tern.infer.</span>Context
        <span class="apidocSignatureSpan">(defs, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Context = function (defs, parent) {
  this.parent = parent;
  this.props = Object.create(null);
  this.protos = Object.create(null);
  this.origins = [];
  this.curOrigin = "ecmascript";
  this.paths = Object.create(null);
  this.definitions = Object.create(null);
  this.purgeGen = 0;
  this.workList = null;
  this.disabledComputing = null;
  this.curSuperCtor = this.curSuper = null;
  this.symbols = Object.create(null)

  exports.withContext(this, function() {
    cx.protos.Object = new Obj(null, "Object.prototype");
    cx.topScope = new Scope();
    cx.topScope.name = "&lt;top&gt;";
    cx.protos.Array = new Obj(true, "Array.prototype");
    cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
    cx.protos.Function.proto = cx.protos.Object;
    cx.protos.RegExp = new Obj(true, "RegExp.prototype");
    cx.protos.String = new Obj(true, "String.prototype");
    cx.protos.Number = new Obj(true, "Number.prototype");
    cx.protos.Boolean = new Obj(true, "Boolean.prototype");
    cx.protos.Symbol = new Obj(true, "Symbol.prototype");
    cx.str = new Prim(cx.protos.String, "string");
    cx.bool = new Prim(cx.protos.Boolean, "bool");
    cx.num = new Prim(cx.protos.Number, "number");
    cx.curOrigin = null;

    if (defs) for (var i = 0; i &lt; defs.length; ++i)
      def.load(defs[i]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as some meta-information and state used by the type inference process.
Almost all operations in the inference module require a context.&lt;/p&gt;
&lt;p&gt; To prevent having to pass the context around through every function, a
form of dynamic binding is usedâ€”the &lt;code&gt;withContext&lt;/code&gt; function executes a
function body with a given object used as the current context.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.Context"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">Context</span>(
defs: [object])&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
A constructor
function for contexts. &lt;code&gt;defs&lt;/code&gt; should be an array of &lt;a href="#typedef"&gt;type definition
 objects&lt;/a&gt;, which will be used to initialize the
global scope.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.DefProp" id="apidoc.element.tern.infer.DefProp">
        function <span class="apidocSignatureSpan">tern.infer.</span>DefProp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefProp = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var getFrom = p.parseType(true);
    p.eat(" ");
    var getTo = p.parseType(true);
    addEffect(fn, function(self, args) {
      var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
      from.forAllProps(function(prop, val, local) {
        if (local &amp;&amp; prop != "&lt;i&gt;")
          to.propagate(new infer.<span class="apidocCodeKeywordSpan">DefProp</span>(prop, val));
      });
    });
  } else {
    throw new Error("Unknown effect type: " + effect);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Fn" id="apidoc.element.tern.infer.Fn">
        function <span class="apidocSignatureSpan">tern.infer.</span>Fn
        <span class="apidocSignatureSpan">(name, self, args, argNames, retval, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fn = function (name, self, args, argNames, retval, generator) {
  Obj.call(this, cx.protos.Function, name);
  this.self = self;
  this.args = args;
  this.argNames = argNames;
  this.retval = retval;
  this.generator = generator
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Constructor for the
type that represents JavaScript objects. &lt;code&gt;proto&lt;/code&gt; may be another
object, or &lt;code&gt;true&lt;/code&gt; as a short-hand for &lt;code&gt;Object.prototype&lt;/code&gt;, or &lt;
;code&gt;null&lt;/code&gt;
for prototype-less objects.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.Fn"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">Fn</span>(name: string
?, self: AVal, args: [AVal], argNames:Â&nbsp;[string], retval:Â&nbsp;AVal)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Constructor for the type that implements functions. Inherits from
&lt;a href="#infer.Obj"&gt;Obj&lt;/a&gt;. The &lt;a href="#infer_aval"&gt;&lt;code&gt;AVal&amp;#
x3c;/code&gt;&lt;/a&gt; types are used to track
the input and output types of the function.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.IfObj" id="apidoc.element.tern.infer.IfObj">
        function <span class="apidocSignatureSpan">tern.infer.</span>IfObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IfObj = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      fnType = last.scope.fnType;
  }
  var result = new infer.AVal;
  if (asNew) {
    var self = new infer.AVal;
    fnType.propagate(new infer.IsCtor(self));
    self.propagate(result, 90);
    fnType.propagate(new infer.IsCallee(self, deps, null, new infer.<span class="apidocCodeKeywordSpan">IfObj</span>(result)));
  } else {
    fnType.propagate(new infer.IsCallee(infer.cx().topScope, deps, null, result));
  }
  return result;
}

infer.registerFunction("angular_callInject", function(argN) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.IsCallee" id="apidoc.element.tern.infer.IsCallee">
        function <span class="apidocSignatureSpan">tern.infer.</span>IsCallee
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsCallee = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return type.call ? type(self, args) : type;
}

function extractProp(type, prop) {
  if (prop == "!ret") {
    if (type.retval) return type.retval;
    var rv = new infer.AVal;
    type.propagate(new infer.<span class="apidocCodeKeywordSpan">IsCallee</span>(infer.ANull, [], null, rv));
    return rv;
  } else {
    return type.getProp(prop);
  }
}

function computedFunc(name, args, retType, generator) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.IsCtor" id="apidoc.element.tern.infer.IsCtor">
        function <span class="apidocSignatureSpan">tern.infer.</span>IsCtor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsCtor = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var last = node.elements[node.elements.length - 1];
    if (last &amp;&amp; /FunctionExpression/.test(last.type))
      fnType = last.scope.fnType;
  }
  var result = new infer.AVal;
  if (asNew) {
    var self = new infer.AVal;
    fnType.propagate(new infer.<span class="apidocCodeKeywordSpan">IsCtor</span>(self));
    self.propagate(result, 90);
    fnType.propagate(new infer.IsCallee(self, deps, null, new infer.IfObj(result)));
  } else {
    fnType.propagate(new infer.IsCallee(infer.cx().topScope, deps, null, result));
  }
  return result;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.IsProto" id="apidoc.element.tern.infer.IsProto">
        function <span class="apidocSignatureSpan">tern.infer.</span>IsProto
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IsProto = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Obj" id="apidoc.element.tern.infer.Obj">
        function <span class="apidocSignatureSpan">tern.infer.</span>Obj
        <span class="apidocSignatureSpan">(proto, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Obj = function (proto, name) {
  if (!this.props) this.props = Object.create(null);
  this.proto = proto === true ? cx.protos.Object : proto;
  if (proto &amp;&amp; proto != cx.protos.Object &amp;&amp; !name &amp;&amp; proto.name &amp;&amp; !(this instanceof Fn)) {
    var match = /^(.*)\.prototype$/.exec(this.proto.name);
    if (match) name = match[1];
  }
  this.name = name;
  this.maybeProps = null;
  this.origin = cx.curOrigin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt; &lt;a id="infer_types"&gt;&lt;/a&gt;Types&lt;/h3&gt;
&lt;p&gt; Tern has a more or less complete implementation of the JavaScript type
system.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.Obj"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">Obj</span>(proto,
name?: string)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Constructor for the
type that represents JavaScript objects. &lt;code&gt;proto&lt;/code&gt; may be another
object, or &lt;code&gt;true&lt;/code&gt; as a short-hand for &lt;code&gt;Object.prototype&lt;/code&gt;, or &lt;
;code&gt;null&lt;/code&gt;
for prototype-less objects.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Prim" id="apidoc.element.tern.infer.Prim">
        function <span class="apidocSignatureSpan">tern.infer.</span>Prim
        <span class="apidocSignatureSpan">(proto, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Prim = function (proto, name) { this.name = name; this.proto = proto; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.PropHasSubset" id="apidoc.element.tern.infer.PropHasSubset">
        function <span class="apidocSignatureSpan">tern.infer.</span>PropHasSubset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PropHasSubset = function () {
  this.origin = cx.curOrigin;
  this.construct.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Scope" id="apidoc.element.tern.infer.Scope">
        function <span class="apidocSignatureSpan">tern.infer.</span>Scope
        <span class="apidocSignatureSpan">(prev, originNode, isBlock, isCatch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Scope = function (prev, originNode, isBlock, isCatch) {
  Obj.call(this, prev || true);
  this.prev = prev;
  this.originNode = originNode
  this.isBlock = !!isBlock
  this.isCatch = !!isCatch
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt; &lt;a id="infer_scopes"&gt;&lt;/a&gt;Scopes&lt;/h3&gt;
&lt;p&gt; Scopes are derived from the &lt;a href="#infer.Obj"&gt;&lt;code&gt;Obj&lt;/code&gt;&lt;/a&amp;#
x3e; type, and variables
are represented the same way as properties.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.Scope"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">Scope</span>(parent
?: Scope)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Constructor for scope
objects. The top scope won&amp;#8217;t have a parent.
&lt;/p&gt;
&lt;/dd&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Sym" id="apidoc.element.tern.infer.Sym">
        function <span class="apidocSignatureSpan">tern.infer.</span>Sym
        <span class="apidocSignatureSpan">(name, originNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Sym = function (name, originNode) {
  Prim.call(this, cx.protos.Symbol, "Symbol")
  this.symName = name
  this.originNode = originNode
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.TimedOut" id="apidoc.element.tern.infer.TimedOut">
        function <span class="apidocSignatureSpan">tern.infer.</span>TimedOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimedOut = function () {
  this.message = "Timed out";
  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var add = cx.workList = function(type, target, weight) {
    if (depth &lt; baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
      list.push(type, target, weight, depth);
  };
  var ret = f(add);
  for (var i = 0; i &lt; list.length; i += 4) {
    if (timeout &amp;&amp; +new Date &gt;= timeout)
      throw new exports.<span class="apidocCodeKeywordSpan">TimedOut</span>();
    depth = list[i + 3] + 1;
    list[i + 1].addType(list[i], list[i + 2]);
  }
  cx.workList = null;
  return ret;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.Type" id="apidoc.element.tern.infer.Type">
        function <span class="apidocSignatureSpan">tern.infer.</span>Type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Type = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.addOrigin" id="apidoc.element.tern.infer.addOrigin">
        function <span class="apidocSignatureSpan">tern.infer.</span>addOrigin
        <span class="apidocSignatureSpan">(origin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOrigin = function (origin) {
  if (cx.origins.indexOf(origin) &lt; 0) cx.origins.push(origin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (spec["!span"]) type.span = spec["!span"];
if (spec["!data"]) type.metaData = spec["!data"];
  }

  function doLoadEnvironment(data, scope) {
var cx = infer.cx(), server = cx.parent

infer.<span class="apidocCodeKeywordSpan">addOrigin</span>(cx.curOrigin = data["!name"] || "env#" + cx.origins
.length);
cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

if (server) server.signal("preLoadDef", data)

passOne(scope, data);

var def = data["!define"];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.analyze" id="apidoc.element.tern.infer.analyze">
        function <span class="apidocSignatureSpan">tern.infer.</span>analyze
        <span class="apidocSignatureSpan">(ast, name, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">analyze = function (ast, name, scope) {
  if (typeof ast == "string") ast = parse(ast);

  if (!name) name = "file#" + cx.origins.length;
  exports.addOrigin(cx.curOrigin = name);

  if (!scope) scope = cx.topScope;
  cx.startAnalysis();

  walk.recursive(ast, scope, null, scopeGatherer);
  if (cx.parent) cx.parent.signal("preInfer", ast, scope)
  walk.recursive(ast, scope, null, inferWrapper);
  if (cx.parent) cx.parent.signal("postInfer", ast, scope)

  cx.curOrigin = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Parse a piece of
code for use by Tern. Will automatically fall back to the
error-tolerant parser if the regular parser can&amp;#8217;t parse the code.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.analyze"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">analyze</span>(
ast: AST, name: string, scope?: Scope)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Analyze a syntax tree. &lt;code&gt;name&lt;/code&gt; will be used to set the origin of types,
properties, and variables produced by this code. The optional &lt;code&gt;scope&lt;/code&gt;
argument can be used to specify a &lt;a href="#infer_scopes"&gt;scope&lt;/a&gt; in which the
code should be analyzed. It will default to the top-level scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.clearScopes" id="apidoc.element.tern.infer.clearScopes">
        function <span class="apidocSignatureSpan">tern.infer.</span>clearScopes
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearScopes = function (ast) {
  walk.simple(ast, scopeClearer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.signal("reset");
  this.cx = new infer.Context(this.defs, this);
  this.uses = 0;
  this.budgets = Object.create(null);
  for (var i = 0; i &lt; this.files.length; ++i) {
    var file = this.files[i];
    if (file.scope) {
      infer.<span class="apidocCodeKeywordSpan">clearScopes</span>(file.ast);
      file.scope = null;
    }
  }
  this.signal("postReset");
},

request: function(doc, c) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.constraint" id="apidoc.element.tern.infer.constraint">
        function <span class="apidocSignatureSpan">tern.infer.</span>constraint
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constraint = function (methods) {
  var ctor = function() {
    this.origin = cx.curOrigin;
    this.construct.apply(this, arguments);
  };
  ctor.prototype = Object.create(ANull);
  for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
  return ctor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;code&gt;addType&lt;/code&gt; method to receive them, which causes all AVals to also be
useable as constraints. The inference engine defines a number of
additional constraints to propagate values in more indirect ways. See
the &lt;a href="http://marijnhaverbeke.nl/blog/tern.html"&gt;blog post&lt;/a&gt; on the
inference algorithm for some examples.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.constraint"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">constraint<!--
span-->(methods: object) â†’ constructor&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
This is a constructor-constructor for constraints. It&amp;#8217;ll create a
constructor with all the given methods copied into its prototype,
which will run its &lt;code&gt;construct&lt;/code&gt; method on its arguments when
instantiated.
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.cx" id="apidoc.element.tern.infer.cx">
        function <span class="apidocSignatureSpan">tern.infer.</span>cx
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cx = function () { return cx; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Calls &lt;code&gt;f&lt;/code&gt; with the current context bound to &lt;code&gt;context&lt;/code&gt;. Basically,
all
code that does something with the inference engine should be wrapped
in such a call.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.cx"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">cx</span>() â†’ Context
&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Returns the current context
object.
&lt;/p&gt;
&lt;/dd&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.didGuess" id="apidoc.element.tern.infer.didGuess">
        function <span class="apidocSignatureSpan">tern.infer.</span>didGuess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">didGuess = function () { return guessing; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/dl&gt;
&lt;p&gt; Whenever the code in &lt;code&gt;lib/infer.js&lt;/code&gt; guesses a type through fuzzy
heuristics (through &lt;a href="#infer.AVal.getType"&gt;&lt;code&gt;getType&lt;/code&gt;&lt;/a&gt; or
&lt;a href="#infer.expressionType"&gt;&lt;code&gt;expressionType&lt;/code&gt;&lt;/a&gt;), it sets a flag
. The
following two function allow access to this flag:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.didGuess"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">didGuess</span>() â†’ bool&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Test whether the
guessing flag is set.
&lt;/p&gt;
&lt;/dd&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.expressionType" id="apidoc.element.tern.infer.expressionType">
        function <span class="apidocSignatureSpan">tern.infer.</span>expressionType
        <span class="apidocSignatureSpan">(found)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionType = function (found) {
  return findType(found.node, found.state);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Similar to &lt;a href="#infer.findExpressionAround"&gt;&lt;code&gt;findExpressionAround&lt;/code&gt;&lt;/
a&gt;,
except that it will return the innermost expression node that spans
the given range, rather than only exact matches.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.expressionType"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">expressionType
</span>(expr: {node, state}) â†’ AVal&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Determine an expression for the given node and scope (as returned by
the functions above). Will return an &lt;a href="#infer_aval"&gt;&lt;code&gt;AVal&lt;/code&gt;&lt;/a&gt;
; or plain
&lt;a href="#infer_types"&gt;&lt;code&gt;Type&lt;/code&gt;&lt;/a&gt;.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.findExpressionAround" id="apidoc.element.tern.infer.findExpressionAround">
        function <span class="apidocSignatureSpan">tern.infer.</span>findExpressionAround
        <span class="apidocSignatureSpan">(ast, start, end, defaultScope, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExpressionAround = function (ast, start, end, defaultScope, filter) {
  var test = filter || function(_t, node) {
    if (start != null &amp;&amp; node.start &gt; start) return false;
    if (node.type == "Identifier" &amp;&amp; node.name == "âœ–") return false;
    return typeFinder.hasOwnProperty(node.type);
  };
  return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
offset. &lt;code&gt;scope&lt;/code&gt; can be given to override the outer scope, which
defaults to the context&amp;#8217;s top scope. Will return a &lt;code&gt;{node, state}&lt;/code&gt;
object if successful, where &lt;code&gt;node&lt;/code&gt; is AST node, and &lt;code&gt;state&lt;/code&gt; is the
scope at that point. Returns &lt;code&gt;null&lt;/code&gt; if unsuccessful.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.findExpressionAround"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">findExpressionAround
</span>(ast: AST, start: number?, end:Â&nbsp;number, scope?:Â&nbsp;Scope) â†’ {node,Â&nbsp;state}&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Similar to &lt;a href="#infer.findExpressionAround"&gt;&lt;code&gt;findExpressionAround&lt;/code&gt;&lt;/
a&gt;,
except that it will return the innermost expression node that spans
the given range, rather than only exact matches.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.findExpressionAt" id="apidoc.element.tern.infer.findExpressionAt">
        function <span class="apidocSignatureSpan">tern.infer.</span>findExpressionAt
        <span class="apidocSignatureSpan">(ast, start, end, defaultScope, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExpressionAt = function (ast, start, end, defaultScope, filter) {
  var test = filter || function(_t, node) {
    if (node.type == "Identifier" &amp;&amp; node.name == "âœ–") return false;
    return typeFinder.hasOwnProperty(node.type);
  };
  return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt; &lt;a id="infer_util"&gt;&lt;/a&gt;Utilities&lt;/h3&gt;
&lt;p&gt; These are miscellaneous utilities that come in helpful when doing code
analysis.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.findExpressionAt"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">findExpressionAt
</span>(ast: AST, start: number?, end: number, scope?:Â&nbsp;Scope) â†’ {node,Â&nbsp;state}&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Searches the given syntax tree for an expression that ends at the
given end offset and, if &lt;code&gt;start&lt;/code&gt; is given, starts at the given start
offset. &lt;code&gt;scope&lt;/code&gt; can be given to override the outer scope, which
defaults to the context&amp;#8217;s top scope. Will return a &lt;code&gt;{node, state}&lt;/code&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.findPropRefs" id="apidoc.element.tern.infer.findPropRefs">
        function <span class="apidocSignatureSpan">tern.infer.</span>findPropRefs
        <span class="apidocSignatureSpan">(ast, scope, objType, name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPropRefs = function (ast, scope, objType, name, f) {
  // Find the type which owns the property in hierarchy
  while (objType &amp;&amp; !objType.props[name] &amp;&amp; !(objType.maybeProps &amp;&amp; objType.maybeProps[name])) {
    objType = objType.proto;
  }
  if (!objType) throw new Error("Couldn't locate property in the base object type.");

  function isObjTypeProto(type) {
    // Check whether the found type has objType in its hierarchy
    while (type &amp;&amp; type != objType) {
      // Ff property is overriden higher in the hierarchy, return false
      if (type.props[name] || (type.maybeProps &amp;&amp; type.maybeProps[name])) {
        return false;
      }
      type = type.proto;
    }
    return type;
  }

  walk.simple(ast, {
    MemberExpression: function(node, scope) {
      if (node.computed || propName(node) != name) return;
      if (isObjTypeProto(findType(node.object, scope).getType())) f(node.property, scope);
    },
    ObjectExpression: function(node, scope) {
      if (findType(node, scope).getType() != objType) return;
      for (var i = 0; i &lt; node.properties.length; ++i)
        if (propName(node.properties[i]) == name) f(node.properties[i].key, scope);
    },
    MethodDefinition: function(node) {
      if (propName(node) != name) return;
      if (node.value &amp;&amp; isObjTypeProto(getThis(node.value.scope).getType())) f(node.key, node.value.scope);
    }
  }, simpleWalker, scope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Will traverse the given syntax tree, using &lt;code&gt;scope&lt;/code&gt; as the starting
scope, looking for references to variable &lt;code&gt;name&lt;/code&gt; that resolve to scope
&lt;code&gt;refScope&lt;/code&gt;, and call &lt;code&gt;f&lt;/code&gt; with the node of the reference and its local
scope for each of them.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.findPropRefs"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">findPropRefs
</span>(ast: AST, scope: Scope, objType: Obj, propName:Â&nbsp;string, f:Â&nbsp;fn(AST))&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Analogous to &lt;a href="#infer.findRefs"&gt;&lt;code&gt;findRefs&lt;/code&gt;&lt;/a&gt;, but used to
look for
references to a specific property instead. Whereas &lt;code&gt;findRefs&lt;/code&gt; is
precise, this is dependent on type inference, and thus can not be
relied on to be precise.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.findRefs" id="apidoc.element.tern.infer.findRefs">
        function <span class="apidocSignatureSpan">tern.infer.</span>findRefs
        <span class="apidocSignatureSpan">(ast, baseScope, name, refScope, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRefs = function (ast, baseScope, name, refScope, f) {
  function handleId(node, scope, ancestors) {
    if (node.name != name ||
        (node == ast.id &amp;&amp; ast.type == "FunctionDeclaration")) return;
    for (var s = scope; s; s = s.prev) {
      if (s == refScope) f(node, scope, ancestors);
      if (name in s.props) return;
    }
  }
  walk.ancestor(ast, {Identifier: handleId, VariablePattern: handleId},
                exports.fullVisitor, baseScope)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Find the scope at a given position in the syntax tree. The &lt;code&gt;scope&lt;/code&gt;
parameter can be used to override the scope used for code that isn&amp;#8217;t
wrapped in any function.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.findRefs"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">findRefs</span>(ast: AST, scope: Scope, name: string, refScope:Â&nbsp;Scope, f:Â&nbsp;fn(AST,Â&nbsp;Scope))&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Will traverse the given syntax tree, using &lt;code&gt;scope&lt;/code&gt; as the starting
scope, looking for references to variable &lt;code&gt;name&lt;/code&gt; that resolve to scope
&lt;code&gt;refScope&lt;/code&gt;, and call &lt;code&gt;f&lt;/code&gt; with the node of the reference and its local
scope for each of them.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.forAllLocalsAt" id="apidoc.element.tern.infer.forAllLocalsAt">
        function <span class="apidocSignatureSpan">tern.infer.</span>forAllLocalsAt
        <span class="apidocSignatureSpan">(ast, pos, defaultScope, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAllLocalsAt = function (ast, pos, defaultScope, f) {
  var scope = scopeAt(ast, pos, defaultScope);
  scope.gatherProperties(f, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (!completions.length &amp;&amp; query.guess !== false &amp;&amp; objType &amp;&amp; objType.guessProperties)
    objType.guessProperties(function(p, o, d) {if (p != prop &amp;&amp; p != "âœ–") gather(p, o, d);});
  if (!completions.length &amp;&amp; word.length &gt;= 2 &amp;&amp; query.guess !== false)
    for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
  hookname = "memberCompletion";
} else {
  infer.<span class="apidocCodeKeywordSpan">forAllLocalsAt</span>(file.ast, wordStart, file.scope, gather);
  if (query.includeKeywords) {
    (srv.options.ecmaVersion &gt;= 6 ? jsKeywordsES6 : jsKeywords).forEach(function(kw) {
      gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
    });
  };
  hookname = "variableCompletion";
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.forAllPropertiesOf" id="apidoc.element.tern.infer.forAllPropertiesOf">
        function <span class="apidocSignatureSpan">tern.infer.</span>forAllPropertiesOf
        <span class="apidocSignatureSpan">(type, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAllPropertiesOf = function (type, f) {
  type.gatherProperties(f, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    prop = word;
  }
}

if (prop != null) {
  srv.cx.completingProperty = prop;

  if (objType) infer.<span class="apidocCodeKeywordSpan">forAllPropertiesOf</span>(objType, gather);

  if (!completions.length &amp;&amp; query.guess !== false &amp;&amp; objType &amp;&amp; objType.guessProperties)
    objType.guessProperties(function(p, o, d) {if (p != prop &amp;&amp; p != "âœ–") gather(p, o, d);});
  if (!completions.length &amp;&amp; word.length &gt;= 2 &amp;&amp; query.guess !== false)
    for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
  hookname = "memberCompletion";
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.getInstance" id="apidoc.element.tern.infer.getInstance">
        function <span class="apidocSignatureSpan">tern.infer.</span>getInstance
        <span class="apidocSignatureSpan">(obj, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInstance = function (obj, ctor) {
  if (ctor === false) return new Obj(obj);

  if (!ctor) ctor = obj.hasCtor;
  if (!obj.instances) obj.instances = [];
  for (var i = 0; i &lt; obj.instances.length; ++i) {
    var cur = obj.instances[i];
    if (cur.ctor == ctor) return cur.instance;
  }
  var instance = new Obj(obj, ctor &amp;&amp; ctor.name);
  instance.origin = obj.origin;
  obj.instances.push({ctor: ctor, instance: instance});
  return instance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (top &amp;&amp; this.base) {
    this.base.proto = base
    var name = base.hasCtor &amp;&amp; base.hasCtor.name || base.name
    if (name) this.base.name = name
    return this.base
  }
  if (top &amp;&amp; this.forceNew) return new infer.Obj(base);
  return infer.<span class="apidocCodeKeywordSpan">getInstance</span>(base);
} else if (this.eat(":")) {
  var name = this.word(/[\w$\.]/)
  return infer.getSymbol(name)
} else if (comp &amp;&amp; this.eat("!")) {
  var arg = this.word(/\d/);
  if (arg) {
    arg = Number(arg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.getSymbol" id="apidoc.element.tern.infer.getSymbol">
        function <span class="apidocSignatureSpan">tern.infer.</span>getSymbol
        <span class="apidocSignatureSpan">(name, originNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSymbol = function (name, originNode) {
  var cleanName = name.replace(/[^\w$\.]/g, "_")
  var known = cx.symbols[cleanName]
  if (known) {
    if (originNode &amp;&amp; !known.originNode) known.originNode = originNode
    return known
  }
  return cx.symbols[cleanName] = new Sym(cleanName, originNode)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (name) this.base.name = name
    return this.base
  }
  if (top &amp;&amp; this.forceNew) return new infer.Obj(base);
  return infer.getInstance(base);
} else if (this.eat(":")) {
  var name = this.word(/[\w$\.]/)
  return infer.<span class="apidocCodeKeywordSpan">getSymbol</span>(name)
} else if (comp &amp;&amp; this.eat("!")) {
  var arg = this.word(/\d/);
  if (arg) {
    arg = Number(arg);
    return function(_self, args) {return args[arg] || infer.ANull;};
  } else if (this.eat("this")) {
    return function(self) {return self;};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.parentNode" id="apidoc.element.tern.infer.parentNode">
        function <span class="apidocSignatureSpan">tern.infer.</span>parentNode
        <span class="apidocSignatureSpan">(child, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parentNode = function (child, ast) {
  var stack = [];
  function c(node, st, override) {
    if (node.start &lt;= child.start &amp;&amp; node.end &gt;= child.end) {
      var top = stack[stack.length - 1];
      if (node == child) throw {found: top};
      if (top != node) stack.push(node);
      walk.base[override || node.type](node, st, c);
      if (top != node) stack.pop();
    }
  }
  try {
    c(ast, null);
  } catch (e) {
    if (e.found) return e.found;
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  VariableDeclarator: function(parent, node, get) {
    if (parent.init == node) return get(parent.id)
  }
};
findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

exports.typeFromContext = function(ast, found) {
  var parent = exports.<span class="apidocCodeKeywordSpan">parentNode</span>(found.node, ast);
  var type = null;
  if (findTypeFromContext.hasOwnProperty(parent.type)) {
    var finder = findTypeFromContext[parent.type];
    type = finder &amp;&amp; finder(parent, found.node, function(node, fromContext) {
      var obj = {node: node, state: found.state};
      var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
      return tp || ANull;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.parse" id="apidoc.element.tern.infer.parse">
        function <span class="apidocSignatureSpan">tern.infer.</span>parse
        <span class="apidocSignatureSpan">(text, options, thirdArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (text, options, thirdArg) {
  if (!options || Array.isArray(options)) options = thirdArg
  var ast;
  try { ast = acorn.parse(text, options); }
  catch(e) { ast = acorn_loose.parse_dammit(text, options); }
  return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function loadDef(name) {
var found = findFile(name, "defs", ".json");
if (!found) {
  console.error("Could not find def file " + name);
  process.exit(1);
}
defs.push(JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(found, "utf8")));
}

loadDef("ecmascript");

function loadPlugin(name, val) {
var found = findFile(name, "plugin", ".js");
if (!found) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.propName" id="apidoc.element.tern.infer.propName">
        function <span class="apidocSignatureSpan">tern.infer.</span>propName
        <span class="apidocSignatureSpan">(node, inferInScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propName = function (node, inferInScope) {
  var key = node.property || node.key;
  if (!node.computed &amp;&amp; key.type == "Identifier") return key.name;
  if (key.type == "Literal") {
    if (typeof key.value == "string") return key.value
    if (typeof key.value == "number") return String(key.value)
  }
  if (inferInScope) {
    var symName = symbolName(infer(key, inferInScope))
    if (symName) return node.propName = symName
  } else if (node.propName) {
    return node.propName
  }
  return "&lt;i&gt;";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AssignmentExpression: function(node, scope) {
  if (node.commentsBefore)
    interpretComments(node, node.commentsBefore, scope,
                      infer.expressionType({node: node.left, state: scope}));
},
ObjectExpression: function(node, scope) {
  for (var i = 0; i &lt; node.properties.length; ++i) {
    var prop = node.properties[i], name = infer.<span class="apidocCodeKeywordSpan">propName</span>(prop)
    if (name != "&lt;i&gt;" &amp;&amp; prop.commentsBefore)
      interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name))
  }
},
Class: function(node, scope) {
  var proto = node.objType.getProp("prototype").getObjType()
  if (!proto) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.purge" id="apidoc.element.tern.infer.purge">
        function <span class="apidocSignatureSpan">tern.infer.</span>purge
        <span class="apidocSignatureSpan">(origins, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (origins, start, end) {
  var test = makePredicate(origins, start, end);
  ++cx.purgeGen;
  cx.topScope.purge(test);
  for (var prop in cx.props) {
    var list = cx.props[prop];
    for (var i = 0; i &lt; list.length; ++i) {
      var obj = list[i], av = obj.props[prop];
      if (!av || test(av, av.originNode)) list.splice(i--, 1);
    }
    if (!list.length) delete cx.props[prop];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// PURGING

exports.purge = function(origins, start, end) {
  var test = makePredicate(origins, start, end);
  ++cx.purgeGen;
  cx.topScope.<span class="apidocCodeKeywordSpan">purge</span>(test);
  for (var prop in cx.props) {
    var list = cx.props[prop];
    for (var i = 0; i &lt; list.length; ++i) {
      var obj = list[i], av = obj.props[prop];
      if (!av || test(av, av.originNode)) list.splice(i--, 1);
    }
    if (!list.length) delete cx.props[prop];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.registerFunction" id="apidoc.element.tern.infer.registerFunction">
        function <span class="apidocSignatureSpan">tern.infer.</span>registerFunction
        <span class="apidocSignatureSpan">(name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerFunction = function (name, f) { customFunctions[name] = f; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a href="#plugin_node"&gt;node.js&lt;/a&gt; and &lt;a href="#plugin_requirejs"&gt;RequireJS&amp;#
x3c;/a&gt;, which
teach the Tern server about the dependency management mechanisms
defined by those systems (as well as, for node.js, including types for
the built-in libraries).&lt;/p&gt;
&lt;p&gt; A plugin can use several hooks to add custom behavior.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;
&lt;a id="infer.registerFunction"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">registerFunction
</span>(name: string, f:Â&nbsp;fn(self,Â&nbsp;args,Â&nbsp;argnodes))&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
This is a function in the &lt;a href="#infer"&gt;inference engine module&lt;/a&gt; that
allows custom ways to compute function return types or effects. When a
function is specified to return &lt;code&gt;!custom:myname&lt;/code&gt; or has an effect
&lt;code&gt;"custom myname"&lt;/code&gt;, a call to the function will cause the function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.resetGuessing" id="apidoc.element.tern.infer.resetGuessing">
        function <span class="apidocSignatureSpan">tern.infer.</span>resetGuessing
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetGuessing = function (val) { guessing = val; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;dd&gt;
&lt;p&gt;
Test whether the
guessing flag is set.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.resetGuessing"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">resetGuessing
</span>(val?: bool)&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Reset the
guessing flag.
&lt;/p&gt;
&lt;/dd&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.scopeAt" id="apidoc.element.tern.infer.scopeAt">
        function <span class="apidocSignatureSpan">tern.infer.</span>scopeAt
        <span class="apidocSignatureSpan">(ast, pos, defaultScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeAt = function (ast, pos, defaultScope) {
  var found = walk.findNodeAround(ast, pos, function(_, node) {
    return node.scope;
  });
  if (found) return found.node.scope;
  else return defaultScope || cx.topScope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
Determine an expression for the given node and scope (as returned by
the functions above). Will return an &lt;a href="#infer_aval"&gt;&lt;code&gt;AVal&lt;/code&gt;&lt;/a&gt;
; or plain
&lt;a href="#infer_types"&gt;&lt;code&gt;Type&lt;/code&gt;&lt;/a&gt;.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.scopeAt"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">scopeAt</span>(
ast: AST, pos: number, scope?: Scope) â†’ Scope&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Find the scope at a given position in the syntax tree. The &lt;code&gt;scope&lt;/code&gt;
parameter can be used to override the scope used for code that isn&amp;#8217;t
wrapped in any function.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.simplifyTypes" id="apidoc.element.tern.infer.simplifyTypes">
        function <span class="apidocSignatureSpan">tern.infer.</span>simplifyTypes
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simplifyTypes = function (types) {
  var found = [];
  outer: for (var i = 0; i &lt; types.length; ++i) {
    var tp = types[i];
    for (var j = 0; j &lt; found.length; j++) {
      var similar = similarType(tp, found[j], 0);
      if (similar) {
        found[j] = similar;
        continue outer;
      }
    }
    found.push(tp);
  }
  return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (isType) typeNameStack.pop();
  return name;
}

infer.AVal.prototype.typeName = function() {
  if (this.types.length == 0) return "?";
  if (this.types.length == 1) return typeName(this.types[0]);
  var simplified = infer.<span class="apidocCodeKeywordSpan">simplifyTypes</span>(this.types);
  if (simplified.length &gt; 2) return "?";
  for (var strs = [], i = 0; i &lt; simplified.length; i++)
    strs.push(typeName(simplified[i]));
  return strs.join("|");
};

infer.ANull.typeName = function() { return "?"; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.toString" id="apidoc.element.tern.infer.toString">
        function <span class="apidocSignatureSpan">tern.infer.</span>toString
        <span class="apidocSignatureSpan">(type, maxDepth, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (type, maxDepth, parent) {
  if (!type || type == parent || maxDepth &amp;&amp; maxDepth &lt; -3) return "?";
  return type.toString(maxDepth, parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The syntax node that
defined the type. Only present for object and function types, and even
for those it may be missing (if the type was created by a type
definition file, or synthesized in some other way).
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.Type.toString"&gt;&lt;/a&gt;&lt;code&gt;type.<span class="apidocCodeKeywordSpan">toString<!--
span-->(maxDepth: number) â†’ string&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Return
a string that describes the type. &lt;code&gt;maxDepth&lt;/code&gt; indicates the depth to
which inner types should be shown.
&lt;/p&gt;
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.typeFromContext" id="apidoc.element.tern.infer.typeFromContext">
        function <span class="apidocSignatureSpan">tern.infer.</span>typeFromContext
        <span class="apidocSignatureSpan">(ast, found)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeFromContext = function (ast, found) {
  var parent = exports.parentNode(found.node, ast);
  var type = null;
  if (findTypeFromContext.hasOwnProperty(parent.type)) {
    var finder = findTypeFromContext[parent.type];
    type = finder &amp;&amp; finder(parent, found.node, function(node, fromContext) {
      var obj = {node: node, state: found.state};
      var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
      return tp || ANull;
    });
  }
  return type || exports.expressionType(found);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.typeFromContext = function(ast, found) {
  var parent = exports.parentNode(found.node, ast);
  var type = null;
  if (findTypeFromContext.hasOwnProperty(parent.type)) {
    var finder = findTypeFromContext[parent.type];
    type = finder &amp;&amp; finder(parent, found.node, function(node, fromContext) {
      var obj = {node: node, state: found.state};
      var tp = fromContext ? exports.<span class="apidocCodeKeywordSpan">typeFromContext</span>(ast, obj) : exports.expressionType
(obj);
      return tp || ANull;
    });
  }
  return type || exports.expressionType(found);
};

// Flag used to indicate that some wild guessing was used to produce
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.withContext" id="apidoc.element.tern.infer.withContext">
        function <span class="apidocSignatureSpan">tern.infer.</span>withContext
        <span class="apidocSignatureSpan">(context, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withContext = function (context, f) {
  var old = cx;
  cx = context;
  try { return f(); }
  finally { cx = old; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;p&gt;
A constructor
function for contexts. &lt;code&gt;defs&lt;/code&gt; should be an array of &lt;a href="#typedef"&gt;type definition
 objects&lt;/a&gt;, which will be used to initialize the
global scope.
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;
&lt;a id="infer.withContext"&gt;&lt;/a&gt;&lt;code&gt;infer.<span class="apidocCodeKeywordSpan">withContext
</span>(context: Context, f: fn())&lt;/code&gt;
&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;
Calls &lt;code&gt;f&lt;/code&gt; with the current context bound to &lt;code&gt;context&lt;/code&gt;. Basically,
all
code that does something with the inference engine should be wrapped
in such a call.
&lt;/p&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tern.infer.withTimeout" id="apidoc.element.tern.infer.withTimeout">
        function <span class="apidocSignatureSpan">tern.infer.</span>withTimeout
        <span class="apidocSignatureSpan">(ms, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withTimeout = function (ms, f) {
  var end = +new Date + ms;
  var oldEnd = timeout;
  if (oldEnd &amp;&amp; oldEnd &lt; end) return f();
  timeout = end;
  try { return f(); }
  finally { timeout = oldEnd; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (queryType.fullFile &amp;&amp; file.type == "part")
  return c("Can't run a " + query.type + " query on a file fragment");

infer.resetGuessing()
infer.withContext(srv.cx, function() {
  var result, run = function() { result = queryType.run(srv, query, file); };
  try {
    if (timeBudget) infer.<span class="apidocCodeKeywordSpan">withTimeout</span>(timeBudget[0], run);
    else run();
  } catch (e) {
    if (srv.options.debug &amp;&amp; e.name != "TernError") console.error(e.stack);
    return c(e);
  }
  c(null, result);
});
...</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tern.signal" id="apidoc.module.tern.signal">module tern.signal</a></h1>


    <h2>
        <a href="#apidoc.element.tern.signal.mixin" id="apidoc.element.tern.signal.mixin">
        function <span class="apidocSignatureSpan">tern.signal.</span>mixin
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (obj) {
  obj.on = on; obj.off = off;
  obj.signal = signal;
  obj.signalReturnFirst = signalReturnFirst;
  obj.hasHandler = hasHandler;
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return type.toString(maxDepth, parent);
};

// A variant of AVal used for unknown, dead-end values. Also serves
// as prototype for AVals, Types, and Constraints because it
// implements 'empty' versions of all the methods that the code
// expects.
var ANull = exports.ANull = signal.<span class="apidocCodeKeywordSpan">mixin</span>({
  addType: function() {},
  propagate: function() {},
  getProp: function() { return ANull; },
  forAllProps: function() {},
  hasType: function() { return false; },
  isEmpty: function() { return true; },
  getFunctionType: function() {},
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>